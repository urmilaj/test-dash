import { stat } from "node:fs/promises";
import { join } from "node:path/posix";
import * as clack from "@clack/prompts";
import wrapAnsi from "wrap-ansi";
import { FileBuildEffects, build } from "./build.js";
import { commandRequiresAuthenticationMessage } from "./commandInstruction.js";
import { RateLimiter, runAllWithConcurrencyLimit } from "./concurrency.js";
import { CliError, isApiError, isEnoent, isHttpError } from "./error.js";
import { visitFiles } from "./files.js";
import {
  defaultEffects as defaultAuthEffects,
  formatUser,
  loginInner,
  validWorkspaces
} from "./observableApiAuth.js";
import { ObservableApiClient } from "./observableApiClient.js";
import {
  defaultEffects as defaultConfigEffects,
  getDeployConfig,
  setDeployConfig
} from "./observableApiConfig.js";
import { slugify } from "./slugify.js";
import { Telemetry } from "./telemetry.js";
import { bold, defaultEffects as defaultTtyEffects, inverse, link, underline, yellow } from "./tty.js";
const DEPLOY_POLL_MAX_MS = 1e3 * 60 * 5;
const DEPLOY_POLL_INTERVAL_MS = 1e3 * 5;
const BUILD_AGE_WARNING_MS = 1e3 * 60 * 5;
const defaultEffects = {
  ...defaultConfigEffects,
  ...defaultTtyEffects,
  ...defaultAuthEffects,
  getDeployConfig,
  setDeployConfig,
  clack,
  logger: console,
  input: process.stdin,
  output: process.stdout,
  visitFiles,
  stat
};
async function deploy({
  config,
  message,
  ifBuildMissing,
  ifBuildStale,
  deployPollInterval = DEPLOY_POLL_INTERVAL_MS,
  maxConcurrency
}, effects = defaultEffects) {
  const { clack: clack2 } = effects;
  Telemetry.record({ event: "deploy", step: "start", ifBuildMissing, ifBuildStale });
  clack2.intro(inverse(" observable deploy "));
  let apiKey = await effects.getObservableApiKey(effects);
  const apiClient = new ObservableApiClient(apiKey ? { apiKey, clack: clack2 } : { clack: clack2 });
  const deployConfig = await effects.getDeployConfig(config.root);
  if (deployConfig.workspaceLogin && !deployConfig.workspaceLogin.match(/^@?[a-z0-9-]+$/)) {
    throw new CliError(
      `Found invalid workspace login in ${join(config.root, ".observablehq", "deploy.json")}: ${deployConfig.workspaceLogin}.`
    );
  }
  if (deployConfig.projectSlug && !deployConfig.projectSlug.match(/^[a-z0-9-]+$/)) {
    throw new CliError(
      `Found invalid project slug in ${join(config.root, ".observablehq", "deploy.json")}: ${deployConfig.projectSlug}.`
    );
  }
  const legacyConfig = config;
  if (legacyConfig.deploy && deployConfig.projectId) {
    if (!deployConfig.projectSlug || !deployConfig.workspaceLogin) {
      clack2.log.info("Copying deploy information from the config file to deploy.json.");
      deployConfig.projectSlug = legacyConfig.deploy.project;
      deployConfig.workspaceLogin = legacyConfig.deploy.workspace.replace(/^@/, "");
      effects.setDeployConfig(config.root, deployConfig);
    }
    clack2.log.info("The `deploy` section of your config file is obsolete and can be deleted.");
  }
  let currentUser = null;
  let authError = null;
  try {
    if (apiKey) {
      currentUser = await apiClient.getCurrentUser();
      currentUser = { ...currentUser, workspaces: validWorkspaces(currentUser.workspaces) };
    }
  } catch (error) {
    if (isHttpError(error)) {
      if (error.statusCode === 401)
        authError = "unauthenticated";
      else if (error.statusCode === 403)
        authError = "forbidden";
      else
        throw error;
    } else {
      throw error;
    }
  }
  if (!currentUser) {
    const message2 = authError === "unauthenticated" || authError === null ? "You must be logged in to Observable to deploy. Do you want to do that now?" : "Your authentication is invalid. Do you want to log in to Observable again?";
    const choice = await clack2.confirm({
      message: message2,
      active: "Yes, log in",
      inactive: "No, cancel deploy"
    });
    if (!choice) {
      clack2.outro(yellow("Deploy canceled."));
    }
    if (clack2.isCancel(choice) || !choice)
      throw new CliError("User canceled deploy", { print: false, exitCode: 0 });
    ({ currentUser, apiKey } = await loginInner(effects));
    apiClient.setApiKey(apiKey);
  }
  if (!currentUser)
    throw new CliError(commandRequiresAuthenticationMessage);
  if (deployConfig.projectId && (!deployConfig.projectSlug || !deployConfig.workspaceLogin)) {
    const spinner2 = clack2.spinner();
    clack2.log.warn("The `projectSlug` or `workspaceLogin` is missing from your deploy.json.");
    spinner2.start(`Searching for project ${deployConfig.projectId}`);
    let found = false;
    for (const workspace of currentUser.workspaces) {
      const projects = await apiClient.getWorkspaceProjects(workspace.login);
      const project = projects.find((p) => p.id === deployConfig.projectId);
      if (project) {
        deployConfig.projectSlug = project.slug;
        deployConfig.workspaceLogin = workspace.login;
        effects.setDeployConfig(config.root, deployConfig);
        found = true;
        break;
      }
    }
    if (found) {
      spinner2.stop(`Project @${deployConfig.workspaceLogin}/${deployConfig.projectSlug} found.`);
    } else {
      spinner2.stop(`Project ${deployConfig.projectId} not found. Ignoring\u2026`);
    }
  }
  let deployTarget;
  const projectUpdates = {};
  if (deployConfig.workspaceLogin && deployConfig.projectSlug) {
    try {
      const project = await apiClient.getProject({
        workspaceLogin: deployConfig.workspaceLogin,
        projectSlug: deployConfig.projectSlug
      });
      deployTarget = { create: false, workspace: project.owner, project };
      if (config.title !== project.title)
        projectUpdates.title = config.title;
    } catch (error) {
      if (!isHttpError(error) || error.statusCode !== 404) {
        throw error;
      }
    }
  }
  deployTarget ??= await promptDeployTarget(effects, apiClient, config, currentUser);
  const previousProjectId = deployConfig?.projectId;
  let targetDescription;
  let buildFilePaths = null;
  let doBuild = false;
  let youngestAge;
  try {
    ({ buildFilePaths, youngestAge } = await findBuildFiles(effects, config));
  } catch (error) {
    if (CliError.match(error, { message: /No build files found/ })) {
      switch (ifBuildMissing) {
        case "cancel":
          throw new CliError("No build files found.");
        case "build": {
          doBuild = true;
          break;
        }
        case "prompt": {
          if (!effects.isTty)
            throw new CliError("No build files found. Pass --if-missing=build to automatically rebuild.");
          const choice = await clack2.select({
            message: "No build files found. Do you want to build the project now?",
            options: [
              { value: true, label: "Yes, build now and then deploy" },
              { value: false, label: "No, cancel deploy" }
            ]
          });
          if (clack2.isCancel(choice) || !choice) {
            throw new CliError("User canceled deploy", { print: false, exitCode: 0 });
          }
          doBuild = true;
          break;
        }
      }
    } else {
      throw error;
    }
  }
  if (!doBuild && youngestAge > BUILD_AGE_WARNING_MS) {
    switch (ifBuildStale) {
      case "cancel":
        throw new CliError("Build is stale.");
      case "build": {
        doBuild = true;
        break;
      }
      case "prompt": {
        if (!effects.isTty)
          throw new CliError("Build is stale. Pass --if-stale=build to automatically rebuild.");
        const ageFormatted = youngestAge < 1e3 * 60 * 60 ? `${Math.round(youngestAge / 1e3 / 60)} minutes ago` : youngestAge < 1e3 * 60 * 60 * 12 ? `${Math.round(youngestAge / 1e3 / 60 / 60)} hours ago` : `at ${new Date(Date.now() - youngestAge).toLocaleString()}`;
        const choice = await clack2.select({
          message: `Your project was last built ${ageFormatted}. What do you want to do?`,
          options: [
            { value: "build-now", label: "Rebuild and then deploy" },
            { value: "deploy-stale", label: "Deploy as is" },
            { value: "cancel", label: "Cancel the deploy" }
          ]
        });
        if (clack2.isCancel(choice) || choice === "cancel") {
          throw new CliError("User canceled deploy", { print: false, exitCode: 0 });
        }
        doBuild = choice === "build-now";
      }
    }
  }
  if (doBuild) {
    clack2.log.step("Building project");
    await build({ config }, new FileBuildEffects(config.output, { logger: effects.logger, output: effects.output }));
    ({ buildFilePaths } = await findBuildFiles(effects, config));
  }
  if (!buildFilePaths || !buildFilePaths)
    throw new Error("No build files found.");
  if (!deployTarget.create) {
    targetDescription = `${deployTarget.project.title} (@${deployTarget.workspace.login}/${deployTarget.project.slug})`;
    const previousProjectId2 = deployConfig.projectId;
    if (previousProjectId2 && previousProjectId2 !== deployTarget.project.id) {
      clack2.log.warn(
        `The \`projectId\` in your deploy.json does not match. Continuing will overwrite ${bold(targetDescription)}.`
      );
      if (effects.isTty) {
        const choice = await clack2.confirm({
          message: "Do you want to continue deploying?",
          active: "Yes, overwrite",
          inactive: "No, cancel"
        });
        if (!choice) {
          clack2.outro(yellow("Deploy canceled."));
        }
        if (clack2.isCancel(choice) || !choice) {
          throw new CliError("User canceled deploy", { print: false, exitCode: 0 });
        }
      } else {
        throw new CliError("Cancelling deploy due to misconfiguration.");
      }
    } else if (previousProjectId2) {
      clack2.log.info(`Deploying to ${bold(targetDescription)}.`);
    } else {
      clack2.log.warn(
        `The \`projectId\` in your deploy.json is missing. Continuing will overwrite ${bold(targetDescription)}.`
      );
      if (effects.isTty) {
        const choice = await clack2.confirm({
          message: "Do you want to continue deploying?",
          active: "Yes, overwrite",
          inactive: "No, cancel"
        });
        if (!choice) {
          clack2.outro(yellow("Deploy canceled."));
        }
        if (clack2.isCancel(choice) || !choice) {
          throw new CliError("User canceled deploy", { print: false, exitCode: 0 });
        }
      } else {
        throw new CliError("Running non-interactively, cancelling due to conflictg");
      }
    }
  }
  if (message === void 0) {
    const input = await clack2.text({
      message: "What changed in this deploy?",
      placeholder: "Enter a deploy message (optional)"
    });
    if (clack2.isCancel(input))
      throw new CliError("User canceled deploy", { print: false, exitCode: 0 });
    message = input;
  }
  if (deployTarget.create) {
    try {
      const project = await apiClient.postProject({
        slug: deployTarget.projectSlug,
        title: deployTarget.title,
        workspaceId: deployTarget.workspace.id,
        accessLevel: deployTarget.accessLevel
      });
      deployTarget = { create: false, workspace: deployTarget.workspace, project };
    } catch (error) {
      if (isApiError(error) && error.details.errors.some((e) => e.code === "TOO_MANY_PROJECTS")) {
        clack2.log.error(
          wrapAnsi(
            `The Starter tier can only deploy one project. Upgrade to unlimited projects at ${link(
              `https://observablehq.com/team/@${deployTarget.workspace.login}/settings`
            )}`,
            effects.outputColumns - 4
          )
        );
      } else {
        clack2.log.error(
          wrapAnsi(`Could not create project: ${error instanceof Error ? error.message : error}`, effects.outputColumns)
        );
      }
      clack2.outro(yellow("Deploy canceled"));
      throw new CliError("Error during deploy", { cause: error, print: false });
    }
  }
  await effects.setDeployConfig(config.root, {
    projectId: deployTarget.project.id,
    projectSlug: deployTarget.project.slug,
    workspaceLogin: deployTarget.workspace.login
  });
  let deployId;
  try {
    deployId = await apiClient.postDeploy({ projectId: deployTarget.project.id, message });
  } catch (error) {
    if (isHttpError(error)) {
      if (error.statusCode === 404) {
        throw new CliError(`Project @${deployTarget.workspace.login}/${deployTarget.project.slug} not found.`, {
          cause: error
        });
      } else if (error.statusCode === 403) {
        throw new CliError(
          `You don't have permission to deploy to @${deployTarget.workspace.login}/${deployTarget.project.slug}.`,
          { cause: error }
        );
      }
    }
    throw error;
  }
  const uploadSpinner = clack2.spinner();
  uploadSpinner.start("");
  const rateLimiter = new RateLimiter(5);
  const waitForRateLimit = buildFilePaths.length <= 300 ? () => {
  } : () => rateLimiter.wait();
  await runAllWithConcurrencyLimit(
    buildFilePaths,
    async (path, i) => {
      await waitForRateLimit();
      uploadSpinner.message(`${i + 1} / ${buildFilePaths.length} ${path.slice(0, effects.outputColumns - 10)}`);
      await apiClient.postDeployFile(deployId, join(config.output, path), path);
    },
    { maxConcurrency }
  );
  uploadSpinner.stop(`${buildFilePaths.length} uploaded`);
  await apiClient.postDeployUploaded(deployId);
  const spinner = clack2.spinner();
  spinner.start("Server processing deploy");
  const pollExpiration = Date.now() + DEPLOY_POLL_MAX_MS;
  let deployInfo = null;
  pollLoop:
    while (true) {
      if (Date.now() > pollExpiration) {
        spinner.stop("Deploy timed out");
        throw new CliError(`Deploy failed to process on server: status = ${deployInfo?.status}`);
      }
      deployInfo = await apiClient.getDeploy(deployId);
      switch (deployInfo.status) {
        case "pending":
          break;
        case "uploaded":
          spinner.stop("Deploy complete");
          break pollLoop;
        case "error":
          spinner.stop("Deploy failed");
          throw new CliError("Deploy failed to process on server");
        default:
          spinner.stop("Unknown status");
          throw new CliError(`Unknown deploy status: ${deployInfo.status}`);
      }
      await new Promise((resolve) => setTimeout(resolve, deployPollInterval));
    }
  if (!deployInfo)
    throw new CliError("Deploy failed to process on server");
  if (previousProjectId && previousProjectId === deployTarget.project.id && typeof projectUpdates?.title === "string") {
    await apiClient.postEditProject(deployTarget.project.id, projectUpdates);
  }
  clack2.outro(`Deployed project now visible at ${link(deployInfo.url)}`);
  Telemetry.record({ event: "deploy", step: "finish" });
}
async function findBuildFiles(effects, config) {
  let youngestAge = Infinity;
  const buildFilePaths = [];
  const nowMs = Date.now();
  try {
    for await (const file of effects.visitFiles(config.output)) {
      let stat2;
      const joinedPath = join(config.output, file);
      try {
        stat2 = await effects.stat(joinedPath);
      } catch (error) {
        throw new CliError(`Error accessing file ${file}: ${error}`, { cause: error });
      }
      if (stat2?.isFile()) {
        buildFilePaths.push(file);
        if (nowMs - stat2.ctimeMs < youngestAge) {
          youngestAge = nowMs - stat2.ctimeMs;
        }
      }
    }
  } catch (error) {
    if (isEnoent(error)) {
      throw new CliError(`No build files found at ${config.output}`, { cause: error });
    }
    throw new CliError(`Error enumerating build files: ${error}`, { cause: error });
  }
  if (!buildFilePaths.length) {
    throw new CliError(`No build files found at ${config.output}`);
  }
  return { buildFilePaths, youngestAge };
}
async function promptDeployTarget(effects, api, config, currentUser) {
  if (!effects.isTty)
    throw new CliError("Deploy not configured.");
  const { clack: clack2 } = effects;
  clack2.log.info("To configure deploy, we need to ask you a few questions.");
  if (currentUser.workspaces.length === 0) {
    clack2.log.error(
      `You don\u2019t have any Observable workspaces. Go to ${underline("https://observablehq.com/team/new")} to create one.`
    );
    throw new CliError("No Observable workspace found.", { print: false, exitCode: 1 });
  }
  let workspace;
  if (currentUser.workspaces.length === 1) {
    workspace = currentUser.workspaces[0];
    clack2.log.step(`Deploying to the ${bold(formatUser(workspace))} workspace.`);
  } else {
    const chosenWorkspace = await clack2.select({
      message: "Which Observable workspace do you want to use?",
      options: currentUser.workspaces.map((w) => ({ value: w, label: formatUser(w) })).sort((a, b) => b.value.role.localeCompare(a.value.role) || a.label.localeCompare(b.label)),
      initialValue: currentUser.workspaces[0]
      // the oldest workspace, maybe?
    });
    if (clack2.isCancel(chosenWorkspace)) {
      throw new CliError("User canceled deploy.", { print: false, exitCode: 0 });
    }
    workspace = chosenWorkspace;
  }
  let projectSlug = null;
  let existingProjects = [];
  try {
    existingProjects = await api.getWorkspaceProjects(workspace.login);
  } catch (error) {
    if (isHttpError(error) && error.statusCode === 404) {
      throw new CliError(`Workspace ${workspace.login} not found.`, { cause: error });
    }
    throw error;
  }
  if (existingProjects.length > 0) {
    const chosenProject = await clack2.select({
      message: "Which project do you want to use?",
      options: [
        { value: null, label: "Create a new project" },
        ...existingProjects.map((p) => ({
          value: p.slug,
          label: `${p.title} (${p.slug})`
        })).sort((a, b) => a.label.localeCompare(b.label))
      ]
    });
    if (clack2.isCancel(chosenProject)) {
      throw new CliError("User canceled deploy.", { print: false, exitCode: 0 });
    } else if (chosenProject !== null) {
      return { create: false, workspace, project: existingProjects.find((p) => p.slug === chosenProject) };
    }
  } else {
    const confirmChoice = await clack2.confirm({
      message: "No projects found. Do you want to create a new project?",
      active: "Yes, continue",
      inactive: "No, cancel"
    });
    if (!confirmChoice) {
      clack2.outro(yellow("Deploy canceled."));
    }
    if (clack2.isCancel(confirmChoice) || !confirmChoice) {
      throw new CliError("User canceled deploy.", { print: false, exitCode: 0 });
    }
  }
  let title = config.title;
  if (title === void 0) {
    clack2.log.warn("You haven\u2019t configured a title for your project.");
    const titleChoice = await clack2.text({
      message: "What title do you want to use?",
      placeholder: "Enter a project title",
      validate: (title2) => title2 ? void 0 : "A title is required."
    });
    if (clack2.isCancel(titleChoice)) {
      throw new CliError("User canceled deploy.", { print: false, exitCode: 0 });
    }
    title = titleChoice;
    clack2.log.info("You should add this title to your observablehq.config.js file.");
  }
  const defaultProjectSlug = config.title ? slugify(config.title) : "";
  const projectSlugChoice = await clack2.text({
    message: "What slug do you want to use?",
    placeholder: defaultProjectSlug,
    defaultValue: defaultProjectSlug,
    validate: (slug) => !slug || slug.match(/^[a-z0-9-]+$/) ? void 0 : "Slugs must be lowercase and contain only letters, numbers, and hyphens."
  });
  if (clack2.isCancel(projectSlugChoice)) {
    throw new CliError("User canceled deploy.", { print: false, exitCode: 0 });
  }
  projectSlug = projectSlugChoice;
  const accessLevel = await clack2.select({
    message: "Who is allowed to access your project?",
    options: [
      { value: "private", label: "Private", hint: "only allow workspace members" },
      { value: "public", label: "Public", hint: "allow anyone" }
    ]
  });
  if (clack2.isCancel(accessLevel)) {
    throw new CliError("User canceled deploy.", { print: false, exitCode: 0 });
  }
  return { create: true, workspace, projectSlug, title, accessLevel };
}
export {
  deploy,
  promptDeployTarget
};
