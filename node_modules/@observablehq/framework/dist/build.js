import { createHash } from "node:crypto";
import { existsSync } from "node:fs";
import { access, constants, copyFile, readFile, writeFile } from "node:fs/promises";
import { basename, dirname, extname, join } from "node:path/posix";
import { CliError, isEnoent } from "./error.js";
import { getClientPath, prepareOutput, visitMarkdownFiles } from "./files.js";
import { getModuleHash } from "./javascript/module.js";
import { transpileModule } from "./javascript/transpile.js";
import { parseMarkdown } from "./markdown.js";
import { extractNpmSpecifier, populateNpmCache, resolveNpmImport } from "./npm.js";
import { isPathImport, relativePath, resolvePath } from "./path.js";
import { renderPage } from "./render.js";
import { getModuleResolver, getResolvers } from "./resolvers.js";
import { resolveImportPath, resolveStylesheetPath } from "./resolvers.js";
import { bundleStyles, rollupClient } from "./rollup.js";
import { searchIndex } from "./search.js";
import { Telemetry } from "./telemetry.js";
import { faint, yellow } from "./tty.js";
async function build({ config, addPublic = true }, effects = new FileBuildEffects(config.output)) {
  const { root, loaders } = config;
  Telemetry.record({ event: "build", step: "start" });
  let pageCount = 0;
  for await (const sourceFile of visitMarkdownFiles(root)) {
    await access(join(root, sourceFile), constants.R_OK);
    pageCount++;
  }
  if (!pageCount)
    throw new CliError(`Nothing to build: no page files found in your ${root} directory.`);
  effects.logger.log(`${faint("found")} ${pageCount} ${faint(`page${pageCount === 1 ? "" : "s"} in`)} ${root}`);
  const pages = /* @__PURE__ */ new Map();
  const files = /* @__PURE__ */ new Set();
  const localImports = /* @__PURE__ */ new Set();
  const globalImports = /* @__PURE__ */ new Set();
  const stylesheets = /* @__PURE__ */ new Set();
  for await (const sourceFile of visitMarkdownFiles(root)) {
    const sourcePath = join(root, sourceFile);
    const path = join("/", dirname(sourceFile), basename(sourceFile, ".md"));
    const options = { path, ...config };
    effects.output.write(`${faint("parse")} ${sourcePath} `);
    const start = performance.now();
    const source = await readFile(sourcePath, "utf8");
    const page = parseMarkdown(source, options);
    if (page?.data?.draft) {
      effects.logger.log(faint("(skipped)"));
      continue;
    }
    const resolvers = await getResolvers(page, { root, path: sourceFile, loaders });
    const elapsed = Math.floor(performance.now() - start);
    for (const f of resolvers.assets)
      files.add(resolvePath(sourceFile, f));
    for (const f of resolvers.files)
      files.add(resolvePath(sourceFile, f));
    for (const i of resolvers.localImports)
      localImports.add(resolvePath(sourceFile, i));
    for (const i of resolvers.globalImports)
      globalImports.add(resolvePath(sourceFile, resolvers.resolveImport(i)));
    for (const s of resolvers.stylesheets)
      stylesheets.add(/^\w+:/.test(s) ? s : resolvePath(sourceFile, s));
    effects.output.write(`${faint("in")} ${(elapsed >= 100 ? yellow : faint)(`${elapsed}ms`)}
`);
    pages.set(sourceFile, { page, resolvers });
  }
  const aliases = /* @__PURE__ */ new Map();
  if (config.search) {
    globalImports.add("/_observablehq/search.js");
    const contents = await searchIndex(config, effects);
    effects.output.write(`${faint("index \u2192")} `);
    const hash = createHash("sha256").update(contents).digest("hex").slice(0, 8);
    const alias = `/_observablehq/minisearch.${hash}.json`;
    aliases.set("/_observablehq/minisearch.json", alias);
    await effects.writeFile(join("_observablehq", `minisearch.${hash}.json`), contents);
  }
  if (addPublic) {
    for (const path of globalImports) {
      if (path.startsWith("/_observablehq/") && path.endsWith(".js")) {
        const clientPath = getClientPath(path === "/_observablehq/client.js" ? "index.js" : path.slice("/_observablehq/".length));
        effects.output.write(`${faint("build")} ${clientPath} ${faint("\u2192")} `);
        const define = {};
        if (config.search)
          define["global.__minisearch"] = JSON.stringify(relativePath(path, aliases.get("/_observablehq/minisearch.json")));
        const contents = await rollupClient(clientPath, root, path, { minify: true, keepNames: true, define });
        await effects.writeFile(path, contents);
      }
    }
    for (const specifier of stylesheets) {
      if (specifier.startsWith("observablehq:")) {
        const path = `/_observablehq/${specifier.slice("observablehq:".length)}`;
        effects.output.write(`${faint("build")} ${specifier} ${faint("\u2192")} `);
        if (specifier.startsWith("observablehq:theme-")) {
          const match = /^observablehq:theme-(?<theme>[\w-]+(,[\w-]+)*)?\.css$/.exec(specifier);
          const contents = await bundleStyles({ theme: match.groups.theme?.split(",") ?? [], minify: true });
          await effects.writeFile(path, contents);
        } else {
          const clientPath = getClientPath(path.slice("/_observablehq/".length));
          const contents = await bundleStyles({ path: clientPath, minify: true });
          await effects.writeFile(`/_observablehq/${specifier.slice("observablehq:".length)}`, contents);
        }
      } else if (specifier.startsWith("npm:")) {
        effects.output.write(`${faint("copy")} ${specifier} ${faint("\u2192")} `);
        const path = await resolveNpmImport(root, specifier.slice("npm:".length));
        const sourcePath = await populateNpmCache(root, path);
        await effects.copyFile(sourcePath, path);
      } else if (!/^\w+:/.test(specifier)) {
        const sourcePath = join(root, specifier);
        effects.output.write(`${faint("build")} ${sourcePath} ${faint("\u2192")} `);
        const contents = await bundleStyles({ path: sourcePath, minify: true });
        const hash = createHash("sha256").update(contents).digest("hex").slice(0, 8);
        const ext = extname(specifier);
        const alias = `/${join("_import", dirname(specifier), `${basename(specifier, ext)}.${hash}${ext}`)}`;
        aliases.set(resolveStylesheetPath(root, specifier), alias);
        await effects.writeFile(alias, contents);
      }
    }
  }
  for (const file of files) {
    let sourcePath = join(root, file);
    if (!existsSync(sourcePath)) {
      const loader = loaders.find(join("/", file), { useStale: true });
      if (!loader) {
        effects.logger.error("missing referenced file", sourcePath);
        continue;
      }
      try {
        sourcePath = join(root, await loader.load(effects));
      } catch (error) {
        if (!isEnoent(error))
          throw error;
        continue;
      }
    }
    effects.output.write(`${faint("copy")} ${sourcePath} ${faint("\u2192")} `);
    const contents = await readFile(sourcePath);
    const hash = createHash("sha256").update(contents).digest("hex").slice(0, 8);
    const ext = extname(file);
    const alias = `/${join("_file", dirname(file), `${basename(file, ext)}.${hash}${ext}`)}`;
    aliases.set(loaders.resolveFilePath(file), alias);
    await effects.writeFile(alias, contents);
  }
  for (const path of globalImports) {
    if (!path.startsWith("/_npm/"))
      continue;
    effects.output.write(`${faint("copy")} npm:${extractNpmSpecifier(path)} ${faint("\u2192")} `);
    const sourcePath = await populateNpmCache(root, path);
    await effects.copyFile(sourcePath, path);
  }
  const resolveImportAlias = (path) => {
    const hash = getModuleHash(root, path).slice(0, 8);
    const ext = extname(path);
    return `/${join("_import", dirname(path), basename(path, ext))}.${hash}${ext}`;
  };
  for (const path of localImports) {
    const sourcePath = join(root, path);
    if (!existsSync(sourcePath)) {
      effects.logger.error("missing referenced file", sourcePath);
      continue;
    }
    effects.output.write(`${faint("copy")} ${sourcePath} ${faint("\u2192")} `);
    const resolveImport = getModuleResolver(root, path);
    const input = await readFile(sourcePath, "utf-8");
    const contents = await transpileModule(input, {
      root,
      path,
      async resolveImport(specifier) {
        return isPathImport(specifier) ? relativePath(join("_import", path), resolveImportAlias(resolvePath(path, specifier))) : resolveImport(specifier);
      }
    });
    const alias = resolveImportAlias(path);
    aliases.set(resolveImportPath(root, path), alias);
    await effects.writeFile(alias, contents);
  }
  for (const [sourceFile, { page, resolvers }] of pages) {
    const sourcePath = join(root, sourceFile);
    const outputPath = join(dirname(sourceFile), basename(sourceFile, ".md") + ".html");
    const path = join("/", dirname(sourceFile), basename(sourceFile, ".md"));
    const options = { path, ...config };
    effects.output.write(`${faint("render")} ${sourcePath} ${faint("\u2192")} `);
    const html = await renderPage(page, {
      ...options,
      resolvers: {
        ...resolvers,
        resolveFile(specifier) {
          const r = resolvers.resolveFile(specifier);
          const a = aliases.get(resolvePath(path, r));
          return a ? relativePath(path, a) : specifier;
        },
        resolveStylesheet(specifier) {
          const r = resolvers.resolveStylesheet(specifier);
          const a = aliases.get(resolvePath(path, r));
          return a ? relativePath(path, a) : isPathImport(specifier) ? specifier : r;
        },
        resolveImport(specifier) {
          const r = resolvers.resolveImport(specifier);
          const a = aliases.get(resolvePath(path, r));
          return a ? relativePath(path, a) : isPathImport(specifier) ? specifier : r;
        },
        resolveScript(specifier) {
          const r = resolvers.resolveScript(specifier);
          const a = aliases.get(resolvePath(path, r));
          return a ? relativePath(path, a) : specifier;
        }
      }
    });
    await effects.writeFile(outputPath, html);
  }
  Telemetry.record({ event: "build", step: "finish", pageCount });
}
class FileBuildEffects {
  outputRoot;
  logger;
  output;
  constructor(outputRoot, { logger = console, output = process.stdout } = {}) {
    if (!outputRoot)
      throw new Error("missing outputRoot");
    this.logger = logger;
    this.output = output;
    this.outputRoot = outputRoot;
  }
  async copyFile(sourcePath, outputPath) {
    const destination = join(this.outputRoot, outputPath);
    this.logger.log(destination);
    await prepareOutput(destination);
    await copyFile(sourcePath, destination);
  }
  async writeFile(outputPath, contents) {
    const destination = join(this.outputRoot, outputPath);
    this.logger.log(destination);
    await prepareOutput(destination);
    await writeFile(destination, contents);
  }
}
export {
  FileBuildEffects,
  build
};
