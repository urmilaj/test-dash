import { exec } from "node:child_process";
import { accessSync, existsSync, readdirSync, statSync } from "node:fs";
import { constants, copyFile, mkdir, readFile, readdir, stat, writeFile } from "node:fs/promises";
import op from "node:path";
import { basename, dirname, join, normalize } from "node:path/posix";
import { setTimeout as sleep } from "node:timers/promises";
import { fileURLToPath } from "node:url";
import { promisify } from "node:util";
import * as clack from "@clack/prompts";
import untildify from "untildify";
import { cyan, faint, inverse, link, reset } from "./tty.js";
const defaultEffects = {
  clack,
  sleep,
  log(output) {
    console.log(output);
  },
  async mkdir(outputPath, options) {
    await mkdir(outputPath, options);
  },
  async copyFile(sourcePath, outputPath) {
    await copyFile(sourcePath, outputPath);
  },
  async writeFile(outputPath, contents) {
    await writeFile(outputPath, contents);
  }
};
async function create(options = {}, effects = defaultEffects) {
  const { clack: clack2 } = effects;
  clack2.intro(`${inverse(" observable create ")} ${faint(`v${"1.4.0"}`)}`);
  const defaultRootPath = "./hello-framework";
  const defaultRootPathError = validateRootPath(defaultRootPath);
  await clack2.group(
    {
      rootPath: () => clack2.text({
        message: "Where to create your project?",
        placeholder: defaultRootPath,
        defaultValue: defaultRootPathError ? void 0 : defaultRootPath,
        validate: (input) => validateRootPath(input, defaultRootPathError)
      }),
      projectTitle: ({ results: { rootPath } }) => clack2.text({
        message: "What to title your project?",
        placeholder: inferTitle(rootPath),
        defaultValue: inferTitle(rootPath)
      }),
      includeSampleFiles: () => clack2.select({
        message: "Include sample files to help you get started?",
        options: [
          { value: true, label: "Yes, include sample files", hint: "recommended" },
          { value: false, label: "No, create an empty project" }
        ],
        initialValue: true
      }),
      packageManager: () => clack2.select({
        message: "Install dependencies?",
        options: [
          { value: "npm", label: "Yes, via npm", hint: "recommended" },
          { value: "yarn", label: "Yes, via yarn", hint: "recommended" },
          { value: null, label: "No" }
        ],
        initialValue: inferPackageManager("npm")
      }),
      initializeGit: () => clack2.confirm({
        message: "Initialize git repository?"
      }),
      installing: async ({ results: { rootPath, projectTitle, includeSampleFiles, packageManager, initializeGit } }) => {
        rootPath = untildify(rootPath);
        const s = clack2.spinner();
        s.start("Copying template files");
        const template = includeSampleFiles ? "default" : "empty";
        const templateDir = op.resolve(fileURLToPath(import.meta.url), "..", "..", "templates", template);
        const runCommand = packageManager === "yarn" ? "yarn" : `${packageManager ?? "npm"} run`;
        const installCommand = `${packageManager ?? "npm"} install`;
        await effects.sleep(1e3);
        await recursiveCopyTemplate(
          templateDir,
          rootPath,
          {
            runCommand,
            installCommand,
            rootPath,
            projectTitle,
            projectTitleString: JSON.stringify(projectTitle)
          },
          effects
        );
        if (packageManager) {
          s.message(`Installing dependencies via ${packageManager}`);
          await effects.sleep(1e3);
          if (packageManager === "yarn")
            await writeFile(join(rootPath, "yarn.lock"), "");
          await promisify(exec)(installCommand, { cwd: rootPath });
        }
        if (initializeGit) {
          s.message("Initializing git repository");
          await effects.sleep(1e3);
          await promisify(exec)("git init", { cwd: rootPath });
          await promisify(exec)("git add -A", { cwd: rootPath });
        }
        s.stop("Installed! \u{1F389}");
        const instructions = [`cd ${rootPath}`, ...packageManager ? [] : [installCommand], `${runCommand} dev`];
        clack2.note(instructions.map((line) => reset(cyan(line))).join("\n"), "Next steps\u2026");
        clack2.outro(`Problems? ${link("https://observablehq.com/framework/getting-started")}`);
      }
    },
    {
      onCancel: () => {
        clack2.cancel("create canceled");
        process.exit(0);
      }
    }
  );
}
function validateRootPath(rootPath, defaultError) {
  if (rootPath === "")
    return defaultError;
  rootPath = normalize(rootPath);
  if (!canWriteRecursive(rootPath))
    return "Path is not writable.";
  if (!existsSync(rootPath))
    return;
  if (!statSync(rootPath).isDirectory())
    return "File already exists.";
  if (!canWrite(rootPath))
    return "Directory is not writable.";
  if (readdirSync(rootPath).length !== 0)
    return "Directory is not empty.";
}
function inferTitle(rootPath) {
  return basename(rootPath).split(/[-_\s]/).map(([c, ...rest]) => c.toUpperCase() + rest.join("")).join(" ");
}
function canWrite(path) {
  try {
    accessSync(path, constants.W_OK);
    return true;
  } catch {
    return false;
  }
}
function canWriteRecursive(path) {
  while (true) {
    const dir = dirname(path);
    if (canWrite(dir))
      return true;
    if (dir === path)
      break;
    path = dir;
  }
  return false;
}
async function recursiveCopyTemplate(inputRoot, outputRoot, context, effects, stepPath = ".") {
  const templatePath = join(inputRoot, stepPath);
  const templateStat = await stat(templatePath);
  let outputPath = join(outputRoot, stepPath);
  if (templateStat.isDirectory()) {
    try {
      await effects.mkdir(outputPath, { recursive: true });
    } catch {
    }
    for (const entry of await readdir(templatePath)) {
      await recursiveCopyTemplate(inputRoot, outputRoot, context, effects, join(stepPath, entry));
    }
  } else {
    if (templatePath.endsWith(".DS_Store"))
      return;
    if (templatePath.endsWith(".tmpl")) {
      outputPath = outputPath.replace(/\.tmpl$/, "");
      let contents = await readFile(templatePath, "utf8");
      contents = contents.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (_, key) => {
        const val = context[key];
        if (val)
          return val;
        throw new Error(`no template variable ${key}`);
      });
      await effects.writeFile(outputPath, contents);
    } else {
      await effects.copyFile(templatePath, outputPath);
    }
  }
}
function inferPackageManager(defaultValue) {
  const userAgent = process.env["npm_config_user_agent"];
  if (!userAgent)
    return defaultValue;
  const pkgSpec = userAgent.split(" ")[0];
  if (!pkgSpec)
    return defaultValue;
  const [name, version] = pkgSpec.split("/");
  if (!name || !version)
    return defaultValue;
  return name;
}
export {
  create
};
