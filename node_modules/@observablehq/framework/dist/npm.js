import { existsSync } from "node:fs";
import { mkdir, readFile, readdir, writeFile } from "node:fs/promises";
import { dirname, join } from "node:path/posix";
import { simple } from "acorn-walk";
import { rsort, satisfies } from "semver";
import { isEnoent } from "./error.js";
import { findImports, isImportMetaResolve } from "./javascript/imports.js";
import { parseProgram } from "./javascript/parse.js";
import { getStringLiteralValue, isStringLiteral } from "./javascript/source.js";
import { relativePath } from "./path.js";
import { Sourcemap } from "./sourcemap.js";
import { faint } from "./tty.js";
function parseNpmSpecifier(specifier) {
  const parts = specifier.split("/");
  const namerange = specifier.startsWith("@") ? [parts.shift(), parts.shift()].join("/") : parts.shift();
  const ranged = namerange.indexOf("@", 1);
  return {
    name: ranged > 0 ? namerange.slice(0, ranged) : namerange,
    range: ranged > 0 ? namerange.slice(ranged + 1) : void 0,
    path: parts.length > 0 ? parts.join("/") : void 0
  };
}
function formatNpmSpecifier({ name, range, path }) {
  return `${name}${range ? `@${range}` : ""}${path ? `/${path}` : ""}`;
}
function rewriteNpmImports(input, resolve = String) {
  const body = parseProgram(input);
  const output = new Sourcemap(input);
  simple(body, {
    ImportDeclaration: rewriteImport,
    ImportExpression: rewriteImport,
    ExportAllDeclaration: rewriteImport,
    ExportNamedDeclaration: rewriteImport,
    CallExpression: rewriteImportMetaResolve
  });
  function rewriteImport(node) {
    if (node.source && isStringLiteral(node.source)) {
      rewriteImportSource(node.source);
    }
  }
  function rewriteImportMetaResolve(node) {
    if (isImportMetaResolve(node) && isStringLiteral(node.arguments[0])) {
      rewriteImportSource(node.arguments[0]);
    }
  }
  function rewriteImportSource(source) {
    const value = getStringLiteralValue(source);
    const resolved = resolve(value);
    if (value !== resolved)
      output.replaceLeft(source.start, source.end, JSON.stringify(resolved));
  }
  return String(output).replace(/^\/\/# sourceMappingURL=.*$\n?/m, "");
}
const npmRequests = /* @__PURE__ */ new Map();
async function populateNpmCache(root, path) {
  if (!path.startsWith("/_npm/"))
    throw new Error(`invalid npm path: ${path}`);
  const filePath = join(root, ".observablehq", "cache", path);
  if (existsSync(filePath))
    return filePath;
  let promise = npmRequests.get(path);
  if (promise)
    return promise;
  promise = async function() {
    const specifier = extractNpmSpecifier(path);
    const href = `https://cdn.jsdelivr.net/npm/${specifier}`;
    process.stdout.write(`npm:${specifier} ${faint("\u2192")} `);
    const response = await fetch(href);
    if (!response.ok)
      throw new Error(`unable to fetch: ${href}`);
    process.stdout.write(`${filePath}
`);
    await mkdir(dirname(filePath), { recursive: true });
    if (/^application\/javascript(;|$)/i.test(response.headers.get("content-type"))) {
      const source = await response.text();
      const resolver = await getDependencyResolver(root, path, source);
      await writeFile(filePath, rewriteNpmImports(source, resolver), "utf-8");
    } else {
      await writeFile(filePath, Buffer.from(await response.arrayBuffer()));
    }
    return filePath;
  }();
  promise.catch(() => {
  }).then(() => npmRequests.delete(path));
  npmRequests.set(path, promise);
  return promise;
}
async function getDependencyResolver(root, path, input) {
  const body = parseProgram(input);
  const dependencies = /* @__PURE__ */ new Set();
  const { name, range } = parseNpmSpecifier(extractNpmSpecifier(path));
  simple(body, {
    ImportDeclaration: findImport,
    ImportExpression: findImport,
    ExportAllDeclaration: findImport,
    ExportNamedDeclaration: findImport,
    CallExpression: findImportMetaResolve
  });
  function findImport(node) {
    if (node.source && isStringLiteral(node.source)) {
      findImportSource(node.source);
    }
  }
  function findImportMetaResolve(node) {
    if (isImportMetaResolve(node) && isStringLiteral(node.arguments[0])) {
      findImportSource(node.arguments[0]);
    }
  }
  function findImportSource(source) {
    const value = getStringLiteralValue(source);
    if (value.startsWith("/npm/")) {
      const { name: depName, range: depRange } = parseNpmSpecifier(value.slice("/npm/".length));
      if (depName === name)
        return;
      if (existsSync(join(root, ".observablehq", "cache", "_npm", `${depName}@${depRange}`)))
        return;
      dependencies.add(value);
    }
  }
  const resolutions = /* @__PURE__ */ new Map();
  if (dependencies.size > 0) {
    const pkgPath = await populateNpmCache(root, `/_npm/${name}@${range}/package.json`);
    const pkg = JSON.parse(await readFile(pkgPath, "utf-8"));
    for (const dependency of dependencies) {
      const { name: depName, path: depPath = "+esm" } = parseNpmSpecifier(dependency.slice("/npm/".length));
      const range2 = (name === "arquero" || name === "@uwdata/mosaic-core" || name === "@duckdb/duckdb-wasm") && depName === "apache-arrow" ? "latest" : name === "@uwdata/mosaic-core" && depName === "@duckdb/duckdb-wasm" ? "1.28.0" : pkg.dependencies?.[depName] ?? pkg.devDependencies?.[depName] ?? pkg.peerDependencies?.[depName];
      if (range2 === void 0)
        continue;
      resolutions.set(dependency, await resolveNpmImport(root, `${depName}@${range2}/${depPath}`));
    }
  }
  return (specifier) => {
    if (!specifier.startsWith("/npm/"))
      return specifier;
    if (resolutions.has(specifier))
      specifier = resolutions.get(specifier);
    else
      specifier = fromJsDelivrPath(specifier);
    return relativePath(path, specifier);
  };
}
let npmVersionCache;
async function initializeNpmVersionCache(root) {
  const cache = /* @__PURE__ */ new Map();
  const cacheDir = join(root, ".observablehq", "cache", "_npm");
  try {
    for (const entry of await readdir(cacheDir)) {
      if (entry.startsWith("@")) {
        for (const subentry of await readdir(join(cacheDir, entry))) {
          const { name, range } = parseNpmSpecifier(`${entry}/${subentry}`);
          const versions = cache.get(name);
          if (versions)
            versions.push(range);
          else
            cache.set(name, [range]);
        }
      } else {
        const { name, range } = parseNpmSpecifier(entry);
        const versions = cache.get(name);
        if (versions)
          versions.push(range);
        else
          cache.set(name, [range]);
      }
    }
  } catch (error) {
    if (!isEnoent(error))
      throw error;
  }
  for (const [key, value] of cache) {
    cache.set(key, rsort(value));
  }
  return cache;
}
const npmVersionRequests = /* @__PURE__ */ new Map();
async function resolveNpmVersion(root, specifier) {
  const { name, range } = specifier;
  if (range && /^\d+\.\d+\.\d+([-+].*)?$/.test(range))
    return range;
  const cache = await (npmVersionCache ??= initializeNpmVersionCache(root));
  const versions = cache.get(specifier.name);
  if (versions) {
    for (const version of versions)
      if (!range || satisfies(version, range))
        return version;
  }
  const href = `https://data.jsdelivr.com/v1/packages/npm/${name}/resolved${range ? `?specifier=${range}` : ""}`;
  let promise = npmVersionRequests.get(href);
  if (promise)
    return promise;
  promise = async function() {
    process.stdout.write(`npm:${formatNpmSpecifier(specifier)} ${faint("\u2192")} `);
    const response = await fetch(href);
    if (!response.ok)
      throw new Error(`unable to fetch: ${href}`);
    const { version } = await response.json();
    if (!version)
      throw new Error(`unable to resolve version: ${formatNpmSpecifier({ name, range })}`);
    const spec = formatNpmSpecifier({ name, range: version });
    process.stdout.write(`npm:${spec}
`);
    cache.set(specifier.name, versions ? rsort(versions.concat(version)) : [version]);
    mkdir(join(root, ".observablehq", "cache", "_npm", spec), { recursive: true });
    return version;
  }();
  promise.catch(() => {
  }).then(() => npmVersionRequests.delete(href));
  npmVersionRequests.set(href, promise);
  return promise;
}
async function resolveNpmImport(root, specifier) {
  const {
    name,
    range = name === "@duckdb/duckdb-wasm" ? "1.28.0" : name === "parquet-wasm" ? "0.5.0" : void 0,
    path = name === "mermaid" ? "dist/mermaid.esm.min.mjs/+esm" : name === "echarts" ? "dist/echarts.esm.min.js" : "+esm"
  } = parseNpmSpecifier(specifier);
  return `/_npm/${name}@${await resolveNpmVersion(root, { name, range })}/${path.replace(/\+esm$/, "_esm.js")}`;
}
const npmImportsCache = /* @__PURE__ */ new Map();
async function resolveNpmImports(root, path) {
  if (!path.startsWith("/_npm/"))
    throw new Error(`invalid npm path: ${path}`);
  let promise = npmImportsCache.get(path);
  if (promise)
    return promise;
  promise = async function() {
    try {
      const filePath = await populateNpmCache(root, path);
      if (!/\.(m|c)?js$/i.test(path))
        return [];
      const source = await readFile(filePath, "utf-8");
      const body = parseProgram(source);
      return findImports(body, path, source);
    } catch (error) {
      console.warn(`unable to fetch or parse ${path}: ${error.message}`);
      return [];
    }
  }();
  npmImportsCache.set(path, promise);
  return promise;
}
function extractNpmSpecifier(path) {
  if (!path.startsWith("/_npm/"))
    throw new Error(`invalid npm path: ${path}`);
  return path.replace(/^\/_npm\//, "").replace(/\/_esm\.js$/, "/+esm");
}
function fromJsDelivrPath(path) {
  if (!path.startsWith("/npm/"))
    throw new Error(`invalid jsDelivr path: ${path}`);
  return path.replace(/^\/npm\//, "/_npm/").replace(/\/\+esm$/, "/_esm.js");
}
export {
  extractNpmSpecifier,
  formatNpmSpecifier,
  fromJsDelivrPath,
  getDependencyResolver,
  parseNpmSpecifier,
  populateNpmCache,
  resolveNpmImport,
  resolveNpmImports,
  rewriteNpmImports
};
