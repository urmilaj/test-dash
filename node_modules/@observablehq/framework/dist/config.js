import { existsSync } from "node:fs";
import { readFile } from "node:fs/promises";
import op from "node:path";
import { basename, dirname, join } from "node:path/posix";
import { cwd } from "node:process";
import { pathToFileURL } from "node:url";
import { LoaderResolver } from "./dataloader.js";
import { visitMarkdownFiles } from "./files.js";
import { formatIsoDate, formatLocaleDate } from "./format.js";
import { createMarkdownIt, parseMarkdown } from "./markdown.js";
import { isAssetPath, parseRelativeUrl, resolvePath } from "./path.js";
import { resolveTheme } from "./theme.js";
function resolveConfig(configPath, root = ".") {
  return op.join(cwd(), root, configPath);
}
async function readConfig(configPath, root) {
  if (configPath === void 0)
    return readDefaultConfig(root);
  return normalizeConfig((await import(pathToFileURL(resolveConfig(configPath, root)).href)).default, root);
}
async function readDefaultConfig(root) {
  const jsPath = resolveConfig("observablehq.config.js", root);
  if (existsSync(jsPath))
    return normalizeConfig((await import(pathToFileURL(jsPath).href)).default, root);
  const tsPath = resolveConfig("observablehq.config.ts", root);
  if (!existsSync(tsPath))
    return normalizeConfig(void 0, root);
  await import("tsx/esm");
  return normalizeConfig((await import(pathToFileURL(tsPath).href)).default, root);
}
async function readPages(root, md) {
  const pages = [];
  for await (const file of visitMarkdownFiles(root)) {
    if (file === "index.md" || file === "404.md")
      continue;
    const source = await readFile(join(root, file), "utf8");
    const parsed = parseMarkdown(source, { path: file, md });
    if (parsed?.data?.draft)
      continue;
    const name = basename(file, ".md");
    const page = { path: join("/", dirname(file), name), name: parsed.title ?? "Untitled" };
    if (name === "index")
      pages.unshift(page);
    else
      pages.push(page);
  }
  return pages;
}
let currentDate = /* @__PURE__ */ new Date();
function setCurrentDate(date = /* @__PURE__ */ new Date()) {
  currentDate = date;
}
async function normalizeConfig(spec = {}, defaultRoot = "docs") {
  let {
    root = defaultRoot,
    output = "dist",
    base = "/",
    sidebar,
    style,
    theme = "default",
    search,
    deploy,
    scripts = [],
    head = "",
    header = "",
    footer = `Built with <a href="https://observablehq.com/" target="_blank">Observable</a> on <a title="${formatIsoDate(
      currentDate
    )}">${formatLocaleDate(currentDate)}</a>.`,
    interpreters
  } = spec;
  root = String(root);
  output = String(output);
  base = normalizeBase(base);
  if (style === null)
    style = null;
  else if (style !== void 0)
    style = { path: String(style) };
  else
    style = { theme: theme = normalizeTheme(theme) };
  const md = createMarkdownIt(spec);
  let { title, pages = await readPages(root, md), pager = true, toc = true } = spec;
  if (title !== void 0)
    title = String(title);
  pages = Array.from(pages, normalizePageOrSection);
  sidebar = sidebar === void 0 ? pages.length > 0 : Boolean(sidebar);
  pager = Boolean(pager);
  scripts = Array.from(scripts, normalizeScript);
  head = String(head);
  header = String(header);
  footer = String(footer);
  toc = normalizeToc(toc);
  deploy = deploy ? { workspace: String(deploy.workspace).replace(/^@+/, ""), project: String(deploy.project) } : null;
  search = Boolean(search);
  interpreters = normalizeInterpreters(interpreters);
  return {
    root,
    output,
    base,
    title,
    sidebar,
    pages,
    pager,
    scripts,
    head,
    header,
    footer,
    toc,
    style,
    deploy,
    search,
    md,
    loaders: new LoaderResolver({ root, interpreters })
  };
}
function normalizeBase(base) {
  base = String(base);
  if (!base.startsWith("/"))
    throw new Error(`base must start with slash: ${base}`);
  if (!base.endsWith("/"))
    base += "/";
  return base;
}
function normalizeTheme(spec) {
  return resolveTheme(typeof spec === "string" ? [spec] : spec === null ? [] : Array.from(spec, String));
}
function normalizeScript(spec) {
  if (typeof spec === "string")
    spec = { src: spec };
  let { src, async = false, type } = spec;
  src = String(src);
  async = Boolean(async);
  type = type == null ? null : String(type);
  return { src, async, type };
}
function normalizePageOrSection(spec) {
  return ("pages" in spec ? normalizeSection : normalizePage)(spec);
}
function normalizeSection(spec) {
  let { name, open = true, pages } = spec;
  name = String(name);
  open = Boolean(open);
  pages = Array.from(pages, normalizePage);
  return { name, open, pages };
}
function normalizePage(spec) {
  let { name, path } = spec;
  name = String(name);
  path = String(path);
  if (isAssetPath(path)) {
    const u = parseRelativeUrl(join("/", path));
    let { pathname } = u;
    pathname = pathname.replace(/\.html$/i, "");
    pathname = pathname.replace(/\/$/, "/index");
    path = pathname + u.search + u.hash;
  }
  return { name, path };
}
function normalizeInterpreters(spec) {
  return Object.fromEntries(
    Object.entries(spec ?? {}).map(([key, value]) => {
      return [String(key), value == null ? null : Array.from(value, String)];
    })
  );
}
function normalizeToc(spec) {
  if (typeof spec === "boolean")
    spec = { show: spec };
  let { label = "Contents", show = true } = spec;
  label = String(label);
  show = Boolean(show);
  return { label, show };
}
function mergeToc(spec, toc) {
  let { label = toc.label, show = toc.show } = typeof spec !== "object" ? { show: spec } : spec ?? {};
  label = String(label);
  show = Boolean(show);
  return { label, show };
}
function mergeStyle(path, style, theme, defaultStyle) {
  return style === void 0 && theme === void 0 ? defaultStyle : style === null ? null : style !== void 0 ? { path: resolvePath(path, String(style)) } : { theme: normalizeTheme(theme) };
}
export {
  mergeStyle,
  mergeToc,
  normalizeConfig,
  readConfig,
  readDefaultConfig,
  setCurrentDate
};
